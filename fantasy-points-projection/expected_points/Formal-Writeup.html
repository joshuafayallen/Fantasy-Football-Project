<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Modeling Receiver Production</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Formal-Writeup_files/libs/clipboard/clipboard.min.js"></script>
<script src="Formal-Writeup_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Formal-Writeup_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Formal-Writeup_files/libs/quarto-html/popper.min.js"></script>
<script src="Formal-Writeup_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Formal-Writeup_files/libs/quarto-html/anchor.min.js"></script>
<link href="Formal-Writeup_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Formal-Writeup_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Formal-Writeup_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Formal-Writeup_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Formal-Writeup_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modeling Receiver Production</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="our-goal" class="level1">
<h1>Our Goal</h1>
<p>The main impetus behind this model is that we are effectively trying to measure a player’s expected fantasy points. For pass plays, we have a few buckets that we can examine. Target share is a relatively straightforward metric that tells us a little bit about their usage in the offense. Really good WRs are likely going to have a high target share compared to their teammates. This is definitely useful for trying to target cornerstone pieces for your roster. However, we would like to build a model that models the expected performance of a player versus their actual production. The end goal is to first build a model that models receiving and then a model that looks at rushing then see who is beating their expectations and get some edges on the waiver wire.</p>
<p>We could obviously just throw everything into a fancy machine learning model and then have it spit out something. I am being facetious because it is a lot more complicated than that. However, I am trying to push myself to do more Bayesian inference and do more things in Python. Luckily, Football is the perfect case because we are not working with a ton of data (comparatively), and it is super noisy! A perfect case for Bayesian analysis. Another benefit of Football data is that it is inherently hierarchical! We have players on teams playing positions in games in quarters on particular downs. There are a ton of different hierarchical structures to model, and there are lots of decisions we have to make. We would love to be able to fit everything into one model!</p>
<p>However, accounting for time, distance, and score differences kind of necessitates flexible approaches to modeling these non-linear relationships. This limits the number of hierarchies we can fit into the model without crashing the virtual environment or making the model run forever. This gives us a few opportunities to not only evaluate the models but also learn how to do Bayesian model averaging! The additional challenge is that the <code>nflreadr</code> provides lots of awesome data, but the presnap data is only provided <strong>after</strong> the season has concluded. So with that being said, let’s get started!</p>
</section>
<section id="receiving" class="level1">
<h1>Receiving</h1>
<p>Receiver production can be bucketed into a few different worlds. For lack of a better terminology, I conceive of receiving production in three ways: touchdown production, catch production, and what happens after they catch the ball. As an illustrative example of what I mean by catch production, let’s say that Josh Allen completes a pass 50 yards down the field, and the receiver is immediately tackled. The receiving yards on that play would be recorded as <span class="math inline">\(\approx\)</span> 50 yards. This is different than if Josh Allen throws a ball 5 yards and the receiver runs 45 yards after the catch. Both are great plays for the offense, but I think taps different aspects of receiver talent and scheme. Each of which are really difficult to separate from each other.</p>
<p>For the purpose of this exercise, I am going to focus on three positions: WR, TE, and RB, because these are the players who generally receive passes, and we actually play in fantasy football. Astute Football fans will notice we are setting aside other offensive personnel, which means that trick plays that target quarterbacks and offensive linemen. So the fun stuff that the Lions did over the last few years, targeting linemen, is not going to be captured. This is not to say that this does not provide interesting or good information, but ultimately not people you can or should pick up on the waiver wire.</p>
<section id="the-yac-model" class="level2">
<h2 class="anchored" data-anchor-id="the-yac-model">The YAC Model</h2>
<p>Yards after catch (YAC) can be an extension of the run game, but is also a way to generate explosive plays without some of the volatility of hitting deep shots. Football is complicated, so there are a lot of reasons why YAC may vary. <a href="https://www.pff.com/news/nfl-pff-data-study-yards-after-the-catch-determined-factors-before-the-catch">PFF</a> makes the argument that separation, box count, QB accuracy, and structural factors that can account for YAC. e are dealing with a few different hierarchies that can affect our model</p>
<p>The first hierarchy that we can talk about are the systems that can effect our model. Kyle Shanahan and Sean McVay are two of the best in the game at designing offenses with high YAC over expected over the past decade or so presenting a good underlying mental model of how complicated this can get. Underlying their systems is the “illusion of complexity” or, effectively,getting to multiple plays from similar offensive groupings. Since Christian McCaffrey got to the Niners Kyle Shanahan uses a lot of 21 personnel, whereas McVay has used more 11 personnel.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> These personnel groupings make defensive coordinators match the defensive personnel to the offensive personnel, which means making decisions about what body types to put on the field.</p>
<p>Let’s take a straightforward example. In 11 personnel, there are 3 WRs on the field, meaning that the defense has to match this with more defensive backs. These are generally lighter body types than what would be on the field in 21 personnel, where there are only two WRs in the formation, meaning they may have to stay in base defense with a mix of heavy and light body types. In 11, you are forcing run-pass conflicts on lighter bodies where defensive backs now have more run-fitting responsibilities than they do against other teams. If they simply cover the WRs and ignore the run, then the Rams can bully you down the field because they have a favorable box and Sean is a good run designer. This forces lighter bodies to come fit the run, something they may not be as adept at, and sets up the play action for the wide receivers well. On the contrary, 21 forces heavier run pass conflicts in other ways. You are putting more coverage responsibilities on the linebackers. You are trying to bring them forward to fit the run while also creating high-low passing conflicts that force them to make decisions on whether to cover the shallow route or the deep route. Each of these systems forces defenders and coordinators to make decisions on how to match personnel and who to cover.</p>
<p>However, an important aspect of the NFL is that it is a copy cat league. Mike McDaniel, the Miami head coach, comes from the Shanahan coaching tree and a few years ago brought what was called the “cheat motion”. This was a short motion to the outside of the formation to get Tyreek Hill moving at full speed. Critically as the season progressed more offenses started to adopt this concept. Critically, defenses also borrow concepts and looks from each other to combat offenses. The Shanahan coaching in 2024 started to struggle against some defenses because defensive coordinators started to manipulate the protection rules upfront.</p>
<p>The next hierarchy that we can talk about is our actual positions. Receivers come in a lot of different flavors! Typically, the way we talk about them is divided into three buckets. In the figure below, we see a really simplified version of the three typical roles or ways we talk about receivers. An X receiver is all out there by themselves on the line of scrimmage. This is a player like Justin Jefferson who has a full arsenal of routes and is a team’s best receiver. The Z receiver is often lined up off the line of scrimmage on the same side as the Y. Prototypically this is somebody like Tyreek Hill who is a deep threat that can draw attention away from the Y receiver. The Y is our slot receiver who can be a tight end like George Kittle or prototypically a receiver like Wes Welker.</p>
<p><img src="receivers.png" class="img-fluid"></p>
<p>However, there is a huge amount of blending of these roles in the NFL. To get touches to your best receivers, you are going to motion your X receiver to where your Y would be. You are also using motion to disguise what you want to do as well as gather more information about the defense. As you may imagine the routes for each of these positions are going to vary, with the Y having a route tree that is in the middle of the field more whereas the X and Z can work the middle as well as the boundaries. These present appreciably different routes, meaning different passing locations. A pass in the middle of the field is going to have more YAC opportunity in some respects because they are working with more field. Whereas an X receiver may have more routes to the boundary, making it harder for them to turn upfield and run since the defensive backs are, in theory right there. Which players occupies these roles matters but also what position occupies these roles also matters. Ceedee Lamb or Ja’Marr Chase at the Y position is a much different body type than George Kittle. All three of these players are great after the catch and above their position means, but what their average YAC is going to be closer to their position averages.</p>
</section>
<section id="the-machine" class="level2">
<h2 class="anchored" data-anchor-id="the-machine">The Machine</h2>
<p>As I learned getting the machines working is hard! While they have very similar structures their are unique challenges to each model. As I outlined in the previous section there are a couple different hierarchies that need to be accounted for. One of the most interesting one and is a little underrated are coaches!</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p> For readers unfamiliar with the parlance 21 is two running backs and one TE. The first number denotes the running back, and the second number denotes the tight end. We treat the offensive line and quarterback as fixed, so that sets aside 6 positions (2 tackles, 2 guards, the center, and the QB), and then we just need to do a bit of adding to get the number of receivers.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>